// ============================================================================
// CONFIGURA√á√ÉO DO FIREBASE
// ============================================================================
// IMPORTANTE: Use as credenciais do Service Account do Firebase
// Arquivo JSON: talents-c856d-firebase-adminsdk-fbsvc-36a7b79743.json
const FIREBASE_CONFIG = {
  email: "firebase-adminsdk-fbsvc@talents-c856d.iam.gserviceaccount.com",
  key: "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCNRvTVgSfW5iDd\na+g7kxkKIL8dxCj/DJ05mcioq/nICieQx0pqxy2fKUD6gFl81Pv4k2sNGPkZ2lX5\nr5ZVZ0W2wB4GQB9a74skxfqsPKPNx/U/blg911och6EWVozPpshWQfkE2HfhaGWm\n5b0vLxMlToMSkmG27Sfm/W8XSLM8xNPPkvPrDXvUvolNMfmTF0tSl7Ydl3K7xifZ\nnKbgoCukbMVSLi1yEnlzhHyPxKb4rbAKjo4YCoQuS3qDZi3Cnpi9EF1uL9cVjjnS\n6cJrtPPF8rQErjc/6cCQVHDyqAni5kY6MUH+8TmbJognqjOTmiBsey8drLU8rhSx\n2Ej/rIQbAgMBAAECggEAAOMWq3aFpQRJ5YoFacZZLGabPJkcNsnB/PgZufFmfpqN\nuAuATJ5Wi37LUSdYKH//2wY18F2dRsvHqWswUvX0ipq3NYvWhpAlfAQgOE+jKaod\nQJo1RKIjBzXUzZqahL1D2cLNSPoA+rHYnY0ovHCbuqq9CPNRWMAxdXJW7br/oRyK\n4oUjYnuRD78efHxTn517JfF23LnALLU9zhUoZ68BWswCN/1IyrpOJE9XIpnu2W68\noyqZ4622czH2GOnKWLlDDnQF+ww8Rd31XDOd9dwHS1+MPFePaxhCIwv+rBZV3GSW\n+IQBNxWJ7LHgOn4m+aSI7vnKPsZ2TAd3fXsAUoDytQKBgQC/uyto4aVT9ElQK7/e\nb2Szxg4LeGK+TLcsFwQHIowkln43SVradCNFvTgc9El5J/Yl7pps+shuhWt6DqKS\nJfgn1QFbyoBu6NX5afdrjBTxD6Jy/imvyE1yuFbOgzR7cG/iTBEJQcj1eJuKCc1P\nqIZDmiQFyjG415gSgs3z4TeMjwKBgQC8ojtup8Pj3xnwRzM0Xwtj9eqGwXEcqeaJ\nti1RJMhqtztgT279IfTh1RqjdD7dVcu29irXOEGxjn2GmYnmkWJ00P2g2zrfPu2c\nsb+JR4ZofS1ZC58eO8cV+YDDqtvK9hIA8s6UwapIWCs8GUVs6TR55hvsUXwvaeYX\n/ZZuT78ttQKBgEOZt6WEIamnMQ4uTrkbp3LnOt56dL5KCC9ocggd+zGPSjMuDvWF\nC0a0f4td6mXoXBZluVcBWRf2vL1NWa6T6poItTDrBjuUppUI8q6dtmiELa/Dw2jy\nA7SWIC0x/5giPaCZV0xfQH6kJpsV96jFb4l4WIkeEEfu4/Rq4DjDyLUrAoGAdcVA\nH+0kU1/WXPrHEFqKzQUbQLkDeubkpXQVRQUXD/GIY7AUVnxd3KVlNUn9ecj4ICn/\nQ1G/SjDxVBkGTOrWMqLMxyI41mr+hQdA01/RnekRZ/fmh0TBHoohB4jkIwqQ4QC3\nU466VuKdU69fdgj/l1/AbUHOq/eNDctooUSu0sUCgYEAnAc8AYDZrlKoaBi7t0+v\nTXHbbB9x0j1TgzW1kyfKYp2T+FGpT8sMsvcvu75a6/tQY8m9xAJGJwY+C97DWLTR\nYuvA5PLt4WCoMRBpg5ibxdp7Z2/+xLbkRhuaTypa07B7+cdARcSiMVX/bFX82q6i\ngnKX4qEqQa2PeX1T5gHPDOU=\n-----END PRIVATE KEY-----\n",
  projectId: "talents-c856d"
};

const FIRESTORE_BATCH_URL = `https://firestore.googleapis.com/v1/projects/${FIREBASE_CONFIG.projectId}/databases/(default)/documents:commit`;
const FIRESTORE_DOCS_URL = `https://firestore.googleapis.com/v1/projects/${FIREBASE_CONFIG.projectId}/databases/(default)/documents/candidates`;
const FIRESTORE_RUN_QUERY_URL = `https://firestore.googleapis.com/v1/projects/${FIREBASE_CONFIG.projectId}/databases/(default)/documents:runQuery`;

// ID da Planilha de Dados (para importa√ß√£o hist√≥rica - opcional)
const SPREADSHEET_ID = "1DKJSelwLZkBag-1ORe-IXT2TVI0XpRpj-CIgR0oaIf0";

// ============================================================================
// GATILHO PRINCIPAL - EXECUTA QUANDO FORMUL√ÅRIO √â ENVIADO
// ============================================================================
/**
 * Fun√ß√£o acionada automaticamente quando um formul√°rio do Google Forms √© enviado
 * N√ÉO modifica a planilha - envia diretamente para o Firebase
 */
function onFormSubmit(e) {
  if (!e || !e.namedValues) {
    Logger.log("‚ö†Ô∏è  Erro: Fun√ß√£o rodada manualmente ou evento inv√°lido.");
    Logger.log("   Esta fun√ß√£o deve ser acionada automaticamente pelo gatilho do Google Forms.");
    return;
  }

  try {
    Logger.log("üìù Novo formul√°rio recebido - Processando...");
    
    const responses = e.namedValues;
    const candidato = mapearFormularioParaCandidato(responses);
    
    if (!candidato || !candidato.fullName) {
      Logger.log("‚ùå Erro: Dados do formul√°rio inv√°lidos ou nome n√£o encontrado.");
      return;
    }
    
    // Verifica se candidato j√° existe no Firebase (duplicata)
    if (candidato.email) {
      Logger.log(`üîç Verificando se candidato j√° existe (email: ${candidato.email})...`);
      const existe = verificarCandidatoExistente(candidato.email);
      
      if (existe) {
        Logger.log(`‚ö†Ô∏è  Candidato j√° existe no Firebase! ID: ${existe.docId}`);
        Logger.log(`   Nome existente: ${existe.fullName || 'N/A'}`);
        Logger.log(`   Email: ${existe.email}`);
        Logger.log(`   ‚è≠Ô∏è  Pulando envio para evitar duplicata.`);
        return;
      }
      Logger.log(`‚úÖ Candidato n√£o encontrado - pode enviar com seguran√ßa.`);
    }
    
    // Envia para o Firebase
    Logger.log(`üì§ Enviando candidato: ${candidato.fullName} (${candidato.email})`);
    const resultado = enviarCandidatoParaFirebase(candidato);
    
    if (resultado.sucesso) {
      Logger.log(`‚úÖ Candidato enviado com sucesso! ID: ${resultado.docId}`);
    } else {
      Logger.log(`‚ùå Erro ao enviar candidato: ${resultado.erro}`);
    }
    
  } catch (error) {
    Logger.log(`‚ùå Erro ao processar formul√°rio: ${error.message}`);
    Logger.log(`   Stack: ${error.stack}`);
  }
}

// ============================================================================
// MAPEAMENTO DE DADOS DO FORMUL√ÅRIO
// ============================================================================
/**
 * Mapeia os dados do Google Forms para o formato do Firebase
 */
function mapearFormularioParaCandidato(responses) {
  const candidato = {};
  
  // Helper para pegar valor do form de forma segura
  const get = (key) => {
    if (!responses[key]) return "";
    return Array.isArray(responses[key]) ? responses[key][0].trim() : String(responses[key]).trim();
  };
  
  // Metadados - IMPORTANTE: Converter para timestamp do Firestore
  const agora = new Date();
  const timestampOriginal = get('Carimbo de data/hora');
  
  // Converte data/hora original para timestamp (se for string, parseia)
  let originalDate = agora;
  if (timestampOriginal) {
    try {
      originalDate = new Date(timestampOriginal);
      if (isNaN(originalDate.getTime())) {
        originalDate = agora; // Fallback se n√£o conseguir parsear
      }
    } catch (e) {
      originalDate = agora;
    }
  }
  
  // Converte para segundos desde epoch (formato Firestore)
  const originalTimestampSeconds = Math.floor(originalDate.getTime() / 1000);
  const createdAtSeconds = Math.floor(agora.getTime() / 1000);
  
  // Formato Firestore timestamp: { timestampValue: "2024-01-19T10:30:00.000Z" }
  candidato.original_timestamp = {
    timestampValue: originalDate.toISOString()
  };
  candidato.createdAt = {
    timestampValue: agora.toISOString()
  };
  
  // Metadados adicionais
  candidato.origin = "forms_automation";
  candidato.createdBy = "Google Forms Automation";
  
  // Identifica√ß√£o e Contato
  candidato.fullName = get('Nome completo:');
  candidato.email = get('E-mail principal:') || get('Endere√ßo de e-mail');
  candidato.email_secondary = get('Endere√ßo de e-mail') || "";
  candidato.phone = get('N¬∫ telefone celular / Whatsapp:');
  
  // Dados Pessoais
  candidato.birthDate = formatarData(get('Data de Nascimento:'));
  candidato.age = parseInt(get('Idade')) || 0;
  candidato.photoUrl = get('Nos envie uma foto atual que voc√™ goste:');
  candidato.maritalStatus = get('Estado civil:') || "";
  candidato.childrenCount = parseInt(get('Se tem filhos, quantos?')) || 0;
  candidato.hasLicense = get('Voc√™ possui CNH tipo B?') || "";
  
  // Localiza√ß√£o (normalizada)
  const cidadeRaw = get('Cidade onde reside:');
  candidato.city = cidadeRaw ? normalizarCidade(cidadeRaw) : "";
  
  // Profissional e Acad√™mico
  candidato.education = get('Forma√ß√£o:');
  candidato.schoolingLevel = get('N√≠vel de escolaridade:');
  candidato.institution = get('Institui√ß√£o de ensino:');
  candidato.graduationDate = formatarData(get('Data de formatura:'));
  candidato.isStudying = get('Em caso de curso superior, est√° cursando neste momento?') || "";
  candidato.experience = get('Experi√™ncias anteriores:');
  candidato.courses = get('Cursos e certifica√ß√µes profissionais.') || "";
  candidato.certifications = get('Certifica√ß√µes profissionais:') || "";
  
  // √Åreas de interesse (normalizada)
  const areasRaw = get('√Åreas de interesse profissional');
  candidato.interestAreas = normalizeInterests(areasRaw);
  
  // Links
  candidato.cvUrl = get('Anexar curr√≠culo:');
  candidato.portfolioUrl = get('Portf√≥lio de trabalho:');
  
  // Processo e Fit Cultural
  candidato.source = normalizarSource(get('Onde voc√™ nos encontrou?') || "Google Forms");
  candidato.referral = get('Voc√™ foi indicado por algum colaborador da Young? Se sim, quem?') || "";
  candidato.salaryExpectation = get('Qual seria sua expectativa salarial?') || "";
  candidato.canRelocate = get('Teria disponibilidade para mudan√ßa de cidade?') || "";
  candidato.references = get('Refer√™ncias profissionais:') || "";
  candidato.typeOfApp = get('Voc√™ est√° se candidatando a uma vaga espec√≠fica...?') || "";
  candidato.freeField = get('Campo Livre, SEJA VOC√ä!') || "";
  
  // Status do Pipeline
  candidato.status = "Inscrito";
  
  // Tags
  candidato.tags = ["Novo Inscrito"];
  
  // Metadados de origem e cria√ß√£o (j√° definidos acima, mas garantindo que est√£o corretos)
  // origin e createdBy j√° foram definidos acima na linha 120-121
  
  return candidato;
}

// ============================================================================
// VERIFICA√á√ÉO DE DUPLICATAS
// ============================================================================
/**
 * Verifica se um candidato j√° existe no Firebase consultando por email
 * Retorna dados do candidato se existir, null se n√£o existir
 */
function verificarCandidatoExistente(email) {
  if (!email || email.trim() === "") return null;
  
  try {
    const token = getServiceAccountToken();
    
    // Query Firestore para buscar por email
    // Nota: Isso requer um √≠ndice no Firestore se o email n√£o for √∫nico
    // Alternativa: usar o docId baseado em email + timestamp (mais eficiente)
    const query = {
      structuredQuery: {
        from: [{ collectionId: "candidates" }],
        where: {
          fieldFilter: {
            field: { fieldPath: "email" },
            op: "EQUAL",
            value: { stringValue: email.trim() }
          }
        },
        limit: 1
      }
    };
    
    const options = {
      method: "post",
      contentType: "application/json",
      headers: { 
        Authorization: "Bearer " + token,
        "Content-Type": "application/json"
      },
      payload: JSON.stringify(query),
      muteHttpExceptions: true
    };
    
    const response = UrlFetchApp.fetch(FIRESTORE_RUN_QUERY_URL, options);
    const statusCode = response.getResponseCode();
    
    if (statusCode !== 200) {
      Logger.log(`  ‚ö†Ô∏è  Erro ao consultar Firebase: Status ${statusCode}`);
      return null;
    }
    
    const responseData = JSON.parse(response.getContentText());
    
    // Se encontrou resultados
    if (responseData && responseData.length > 0 && responseData[0].document) {
      const doc = responseData[0].document;
      const fields = doc.fields || {};
      
      // Extrai dados do documento
      const dados = {};
      for (const key in fields) {
        const field = fields[key];
        if (field.stringValue) dados[key] = field.stringValue;
        else if (field.integerValue) dados[key] = parseInt(field.integerValue);
        else if (field.booleanValue) dados[key] = field.booleanValue === true || field.booleanValue === 'true';
        else if (field.arrayValue) dados[key] = field.arrayValue.values.map(v => v.stringValue || v);
      }
      
      return {
        docId: doc.name.split('/').pop(),
        ...dados
      };
    }
    
    return null;
    
  } catch (error) {
    Logger.log(`  ‚ö†Ô∏è  Erro ao verificar duplicata: ${error.message}`);
    return null;
  }
}

// ============================================================================
// ENVIO PARA FIREBASE
// ============================================================================
/**
 * Envia um candidato para o Firebase Firestore
 * Usa ID √∫nico baseado em email + timestamp para evitar duplicatas
 */
function enviarCandidatoParaFirebase(candidato) {
  try {
    // Gera ID √∫nico baseado em email + timestamp para evitar duplicatas
    // Extrai string do timestamp para gerar ID √∫nico
    const timestampStr = candidato.original_timestamp?.timestampValue || candidato.createdAt?.timestampValue || new Date().toISOString();
    const uniqueString = (candidato.email || "sem_email") + "_" + timestampStr;
    const docId = Utilities.base64EncodeWebSafe(Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, uniqueString));
    
    // Converte dados para formato Firestore
    const fields = {};
    for (const key in candidato) {
      const value = candidato[key];
      if (value === null || value === undefined || value === "") continue;
      
      // Converte para tipo correto do Firestore
      if (key === 'original_timestamp' || key === 'createdAt') {
        // Timestamp do Firestore - j√° est√° no formato correto
        if (value.timestampValue) {
          fields[key] = { timestampValue: value.timestampValue };
        } else if (typeof value === 'string') {
          // Se ainda for string, converte
          fields[key] = { timestampValue: value };
        } else {
          fields[key] = { timestampValue: new Date().toISOString() };
        }
      } else if (Array.isArray(value)) {
        fields[key] = { 
          arrayValue: { 
            values: value.map(v => ({ stringValue: String(v) })) 
          } 
        };
      } else if (typeof value === 'number') {
        fields[key] = { integerValue: value };
      } else if (typeof value === 'boolean') {
        fields[key] = { booleanValue: value };
      } else if (typeof value === 'object' && value.timestampValue) {
        // Objeto timestamp j√° formatado
        fields[key] = { timestampValue: value.timestampValue };
      } else {
        fields[key] = { stringValue: String(value) };
      }
    }
    
    // Prepara opera√ß√£o de escrita (usando update para fazer upsert - criar ou atualizar)
    const docPath = `${FIRESTORE_DOCS_URL}/${docId}`;
    const payload = {
      fields: fields
    };
    
    // Obt√©m token de autentica√ß√£o
    const token = getServiceAccountToken();
    
    // Envia para o Firebase usando REST API
    const options = {
      method: "patch", // PATCH faz upsert (create ou update)
      contentType: "application/json",
      headers: { 
        Authorization: "Bearer " + token,
        "Content-Type": "application/json"
      },
      payload: JSON.stringify(payload),
      muteHttpExceptions: true
    };
    
    const response = UrlFetchApp.fetch(docPath, options);
    const statusCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (statusCode === 200 || statusCode === 201) {
      return {
        sucesso: true,
        docId: docId,
        statusCode: statusCode
      };
    } else {
      Logger.log(`  ‚ö†Ô∏è  Resposta do Firebase: Status ${statusCode}`);
      Logger.log(`  ‚ö†Ô∏è  Erro: ${responseText}`);
      return {
        sucesso: false,
        erro: `Erro Firebase (${statusCode}): ${responseText}`,
        statusCode: statusCode
      };
    }
    
  } catch (error) {
    return {
      sucesso: false,
      erro: error.message
    };
  }
}

// ============================================================================
// AUTENTICA√á√ÉO E TOKENS
// ============================================================================
function getServiceAccountToken() {
  const privateKey = FIREBASE_CONFIG.key.replace(/\\n/g, '\n');
  const clientEmail = FIREBASE_CONFIG.email;
  const header = { alg: "RS256", typ: "JWT" };
  const now = Math.floor(Date.now() / 1000);
  const claim = { 
    iss: clientEmail, 
    scope: "https://www.googleapis.com/auth/datastore", 
    aud: "https://oauth2.googleapis.com/token", 
    exp: now + 3600, 
    iat: now 
  };
  const toSign = Utilities.base64EncodeWebSafe(JSON.stringify(header)) + "." + Utilities.base64EncodeWebSafe(JSON.stringify(claim));
  const signature = Utilities.base64EncodeWebSafe(Utilities.computeRsaSha256Signature(toSign, privateKey));
  const jwt = toSign + "." + signature;
  const params = { 
    method: "post", 
    payload: { 
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer", 
      assertion: jwt 
    }, 
    muteHttpExceptions: true 
  };
  const response = UrlFetchApp.fetch("https://oauth2.googleapis.com/token", params);
  const json = JSON.parse(response.getContentText());
  if (json.error) throw new Error("Erro Token: " + json.error_description);
  return json.access_token;
}

// ============================================================================
// NORMALIZA√á√ÉO DE DADOS
// ============================================================================
function formatarData(valor) {
  if (!valor) return "";
  if (!isNaN(valor) && valor > 20000) { 
    // Formato serial do Excel/Sheets
    const date = new Date((valor - 25569) * 86400 * 1000);
    return date.toISOString().split('T')[0];
  }
  // Tenta parsear como data
  const date = new Date(valor);
  if (!isNaN(date.getTime())) {
    return date.toISOString().split('T')[0];
  }
  return String(valor).trim();
}

function normalizarCidade(city) {
  if (!city || typeof city !== 'string') return "";
  
  const normalized = city.trim();
  const lowerCity = normalized.toLowerCase();
  
  // Remove acentos para compara√ß√£o mais flex√≠vel
  const removeAccents = function(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  };
  
  const lowerCityNoAccents = removeAccents(lowerCity);
  
  // Cidades principais com suas varia√ß√µes
  const mainCities = {
    'Porto Alegre/RS': ['porto alegre', 'porto alegre/rs', 'poa', 'poa/rs', 'portoalegre', 'porto alegre rs', 'p. alegre', 'p. alegre/rs'],
    'Canoas/RS': ['canoas', 'canoas/rs', 'canoas rs'],
    'Bag√©/RS': ['bag√©', 'bage', 'bag√©/rs', 'bage/rs', 'bag√© rs', 'bage rs'],
    'Santo Ant√¥nio da Patrulha/RS': ['santo ant√¥nio da patrulha', 'santo antonio da patrulha', 'sto ant√¥nio da patrulha', 'sto antonio da patrulha', 'santo ant patrulha', 'sto ant patrulha', 'sap', 'sap/rs', 'sap rs', 'santo ant√¥nio da patrulha/rs', 'santo antonio da patrulha/rs', 'sto ant√¥nio da patrulha/rs', 'sto antonio da patrulha/rs', 'santo ant patrulha/rs', 'sto ant patrulha/rs'],
    'Gua√≠ba/RS': ['gua√≠ba', 'guaiba', 'gua√≠ba/rs', 'guaiba/rs', 'gua√≠ba rs', 'guaiba rs'],
    'Os√≥rio/RS': ['os√≥rio', 'osorio', 'os√≥rio/rs', 'osorio/rs', 'os√≥rio rs', 'osorio rs'],
    'Tramanda√≠/RS': ['tramanda√≠', 'tramandai', 'tramanda√≠/rs', 'tramandai/rs', 'tramanda√≠ rs', 'tramandai rs', 'tramandai/rs'],
    'S√£o Borja/RS': ['s√£o borja', 'sao borja', 's√£o borja/rs', 'sao borja/rs', 's√£o borja rs', 'sao borja rs', 's borja', 's borja/rs'],
    "Sant'Ana do Livramento/RS": ["sant'ana do livramento", "santana do livramento", "sant'ana do livramento/rs", "santana do livramento/rs", "sant'ana do livramento rs", "santana do livramento rs", "sant ana do livramento", "sant ana do livramento/rs", "livramento", "livramento/rs", "livramento rs"],
    'Cruz Alta/RS': ['cruz alta', 'cruz alta/rs', 'cruz alta rs', 'cruzalta', 'cruzalta/rs'],
    'Itaqui/RS': ['itaqui', 'itaqui/rs', 'itaqui rs'],
    'Alegrete/RS': ['alegrete', 'alegrete/rs', 'alegrete rs'],
    'Arroio do Sal/RS': ['arroio do sal', 'arroio do sal/rs', 'arroio do sal rs', 'arroio sal', 'arroio sal/rs', 'arroio sal rs'],
    'Torres/RS': ['torres', 'torres/rs', 'torres rs']
  };
  
  // Procura nas cidades principais
  for (const [standardName, variations] of Object.entries(mainCities)) {
    if (lowerCity === standardName.toLowerCase()) {
      return standardName;
    }
    
    for (let i = 0; i < variations.length; i++) {
      const variation = variations[i];
      const lowerVariation = variation.toLowerCase();
      const lowerVariationNoAccents = removeAccents(lowerVariation);
      
      if (lowerCity === lowerVariation || lowerCityNoAccents === lowerVariationNoAccents) {
        return standardName;
      }
      
      if (lowerCity.indexOf(lowerVariation) !== -1 || lowerVariation.indexOf(lowerCity) !== -1) {
        if (lowerVariation.length > 2 && lowerCity.length > 2) {
          return standardName;
        }
      }
    }
    
    const lowerStandard = standardName.toLowerCase();
    const lowerStandardNoAccents = removeAccents(lowerStandard);
    
    if (lowerCity.indexOf(lowerStandardNoAccents) !== -1 || lowerStandardNoAccents.indexOf(lowerCity) !== -1) {
      if (lowerStandard.length > 5 && lowerCity.length > 5) {
        return standardName;
      }
    }
  }
  
  // Se n√£o encontrou, padroniza formato b√°sico
  const words = normalized.split(/\s+/);
  const cleaned = words.map(function(word) {
    if (word.length === 0) return '';
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
  }).join(' ');
  
  // Adiciona /RS se n√£o tiver estado
  if (cleaned.indexOf('/') === -1 && !cleaned.match(/\b(RS|SC|PR|SP|RJ|MG|ES|BA|SE|AL|PE|PB|RN|CE|PI|MA|PA|AP|AM|AC|RO|RR|TO|GO|MT|MS|DF)\b/i)) {
    return cleaned + '/RS';
  }
  
  return cleaned;
}

function normalizeInterests(rawString) {
  if (!rawString) return "";
  // Converte array para string separada por v√≠rgula (compat√≠vel com frontend)
  if (Array.isArray(rawString)) {
    return rawString.join(', ');
  }
  // Se j√° for string, retorna como est√° (normalizada)
  return String(rawString).trim();
}

function normalizarSource(source) {
  if (!source) return "Google Forms";
  const normalized = String(source).trim().toLowerCase();
  
  // Normaliza varia√ß√µes comuns de origem
  const sources = {
    'google': 'Google',
    'google forms': 'Google Forms',
    'facebook': 'Facebook',
    'instagram': 'Instagram',
    'linkedin': 'LinkedIn',
    'indica√ß√£o': 'Indica√ß√£o',
    'indicacao': 'Indica√ß√£o',
    'site': 'Site',
    'outro': 'Outro'
  };
  
  for (const [key, value] of Object.entries(sources)) {
    if (normalized.includes(key)) {
      return value;
    }
  }
  
  // Retorna com primeira letra mai√∫scula
  return source.charAt(0).toUpperCase() + source.slice(1).toLowerCase();
}

// ============================================================================
// CONFIGURA√á√ÉO DE GATILHOS
// ============================================================================
/**
 * Configura gatilho autom√°tico no Google Forms
 * Execute esta fun√ß√£o UMA VEZ para configurar
 */
function setupTriggers() {
  // Remove TODOS os gatilhos existentes que chamam onFormSubmit (incluindo time-based)
  const triggers = ScriptApp.getProjectTriggers();
  let removidos = 0;
  
  triggers.forEach(function(trigger) {
    const handlerFunction = trigger.getHandlerFunction();
    const eventType = trigger.getEventType();
    
    // Remove qualquer gatilho que chame onFormSubmit, especialmente time-based
    if (handlerFunction === 'onFormSubmit') {
      Logger.log(`üóëÔ∏è  Removendo gatilho incorreto: ${handlerFunction} (Tipo: ${eventType})`);
      ScriptApp.deleteTrigger(trigger);
      removidos++;
    }
  });
  
  if (removidos > 0) {
    Logger.log(`‚úÖ ${removidos} gatilho(s) incorreto(s) removido(s).`);
  }
  
  // IMPORTANTE: O gatilho precisa ser criado no contexto do Formul√°rio
  // Se o script est√° vinculado ao Form, isso funcionar√°:
  try {
    const form = FormApp.getActiveForm();
    ScriptApp.newTrigger('onFormSubmit')
      .onFormSubmit()
      .create();
    
    Logger.log("‚úÖ Gatilho CORRETO configurado com sucesso!");
    Logger.log("   - Fun√ß√£o: onFormSubmit");
    Logger.log("   - Tipo: Evento de envio do formul√°rio");
    Logger.log("   - Executa automaticamente quando formul√°rio √© enviado");
    Logger.log("   - Cada novo envio ser√° enviado automaticamente para o Firebase");
  } catch (e) {
    Logger.log("‚ö†Ô∏è  ATEN√á√ÉO: N√£o foi poss√≠vel criar gatilho automaticamente.");
    Logger.log("   Instru√ß√µes manuais:");
    Logger.log("   1. No editor do Apps Script, v√° em: Editar ‚Üí Gatilhos do projeto atual");
    Logger.log("   2. Clique em 'Adicionar gatilho'");
    Logger.log("   3. Selecione:");
    Logger.log("      - Fun√ß√£o: onFormSubmit");
    Logger.log("      - Origem do evento: Do formul√°rio");
    Logger.log("      - Tipo de evento: Ao enviar o formul√°rio");
    Logger.log("   4. Salve");
    Logger.log(`   Erro: ${e.message}`);
  }
}

/**
 * Fun√ß√£o para limpar gatilhos incorretos manualmente
 * Execute esta fun√ß√£o se houver gatilhos time-based chamando onFormSubmit
 */
function limparGatilhosIncorretos() {
  const triggers = ScriptApp.getProjectTriggers();
  let removidos = 0;
  
  Logger.log("üîç Verificando gatilhos existentes...");
  
  triggers.forEach(function(trigger) {
    const handlerFunction = trigger.getHandlerFunction();
    const eventType = trigger.getEventType();
    
    Logger.log(`   - Fun√ß√£o: ${handlerFunction}, Tipo: ${eventType}`);
    
    // Remove qualquer gatilho time-based que chame onFormSubmit
    if (handlerFunction === 'onFormSubmit' && eventType === ScriptApp.EventType.CLOCK) {
      Logger.log(`   ‚ùå Gatilho INCORRETO encontrado (time-based chamando onFormSubmit) - Removendo...`);
      ScriptApp.deleteTrigger(trigger);
      removidos++;
    }
  });
  
  if (removidos > 0) {
    Logger.log(`‚úÖ ${removidos} gatilho(s) incorreto(s) removido(s).`);
    Logger.log("   Agora execute setupTriggers() para configurar o gatilho correto.");
  } else {
    Logger.log("‚úÖ Nenhum gatilho incorreto encontrado.");
  }
}

// ============================================================================
// IMPORTA√á√ÉO EM MASSA (PARA HIST√ìRICO DA PLANILHA - OPCIONAL)
// ============================================================================
/**
 * Importa dados hist√≥ricos da planilha do Google Sheets em lotes
 * √ötil para importar dados antigos que j√° estavam na planilha
 * IMPORTANTE: S√≥ funciona se voc√™ tiver acesso √† planilha vinculada
 */
function importarEmLotes() {
  try {
    const BATCH_SIZE = 400; // Limite seguro por requisi√ß√£o

    // Abre a planilha pelo ID espec√≠fico
    const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = spreadsheet.getSheets()[0];
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const rows = data.slice(1); // Remove cabe√ßalho

    Logger.log(`üìä Iniciando importa√ß√£o hist√≥rica de ${rows.length} linhas da planilha...`);

    let totalEnviado = 0;
    let totalErros = 0;
    let totalIgnorados = 0; // Linhas vazias ou inv√°lidas
    const totalLotes = Math.ceil(rows.length / BATCH_SIZE);

    // Loop principal: Processa em blocos de 400
    for (let i = 0; i < rows.length; i += BATCH_SIZE) {
      const loteNum = Math.floor(i / BATCH_SIZE) + 1;
      const chunk = rows.slice(i, i + BATCH_SIZE);
      const writes = [];
      const inicioLote = new Date();

      Logger.log(`‚è≥ Processando lote ${loteNum}/${totalLotes} (linhas ${i + 1} a ${Math.min(i + BATCH_SIZE, rows.length)})...`);
      Logger.log(`   üìã Preparando ${chunk.length} registros para envio...`);

      chunk.forEach((row, index) => {
        // Pula linhas vazias se houver
        if (!row[0] && !row[2]) return;

        const candidato = rowToCandidateObject(row, headers);
        
        if (!candidato || !candidato.fullName) return;
        
        // NOTA: Removida verifica√ß√£o de duplicata durante importa√ß√£o em massa
        // O Firebase faz upsert automaticamente (cria ou atualiza) com base no docId √∫nico
        // Isso torna a importa√ß√£o muito mais r√°pida
        
        // Gera ID √∫nico para o documento (baseado em email + timestamp)
        const timestampStr = candidato.original_timestamp?.timestampValue || candidato.createdAt?.timestampValue || new Date().toISOString();
        const uniqueString = (candidato.email || "sem_email") + "_" + timestampStr;
        const docId = Utilities.base64EncodeWebSafe(Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, uniqueString));
        
        // Converte para formato Firestore
        const fields = {};
        for (const key in candidato) {
          const value = candidato[key];
          if (value === null || value === undefined || value === "") continue;
          
          // Trata timestamps do Firestore
          if (key === 'original_timestamp' || key === 'createdAt') {
            if (value.timestampValue) {
              fields[key] = { timestampValue: value.timestampValue };
            } else if (typeof value === 'string') {
              fields[key] = { timestampValue: value };
            } else {
              fields[key] = { timestampValue: new Date().toISOString() };
            }
          } else if (Array.isArray(value)) {
            fields[key] = { arrayValue: { values: value.map(v => ({ stringValue: String(v) })) } };
          } else if (typeof value === 'number') {
            fields[key] = { integerValue: value };
          } else if (typeof value === 'boolean') {
            fields[key] = { booleanValue: value };
          } else if (typeof value === 'object' && value.timestampValue) {
            fields[key] = { timestampValue: value.timestampValue };
          } else {
            fields[key] = { stringValue: String(value) };
          }
        }

        const docPath = `projects/${FIREBASE_CONFIG.projectId}/databases/(default)/documents/candidates/${docId}`;

        writes.push({
          update: {
            name: docPath,
            fields: fields
          }
        });
      });

      Logger.log(`   üì¶ ${writes.length} documento(s) preparado(s) para envio...`);

      if (writes.length > 0) {
        try {
          Logger.log(`   üöÄ Enviando lote ${loteNum} para Firebase...`);
          enviarBatchFirestore(writes);
          totalEnviado += writes.length;
          const tempoLote = ((new Date() - inicioLote) / 1000).toFixed(2);
          Logger.log(`  ‚úÖ Lote ${loteNum} enviado com sucesso! (${writes.length} registro(s) em ${tempoLote}s)`);
        } catch (e) {
          totalErros += writes.length;
          Logger.log(`  ‚ùå Erro ao enviar lote ${loteNum}: ${e.message}`);
          Logger.log(`     Stack: ${e.stack}`);
        }
      } else {
        totalIgnorados += chunk.length;
        Logger.log(`  ‚ö†Ô∏è  Lote ${loteNum} vazio - nenhum registro v√°lido encontrado.`);
      }
      
      // Pausa para evitar limite de taxa (apenas entre lotes, n√£o no √∫ltimo)
      if (loteNum < totalLotes) {
        Logger.log(`   ‚è∏Ô∏è  Pausa de 1 segundo antes do pr√≥ximo lote...`);
        Utilities.sleep(1000);
      }
    }
    
    // Resumo final
    Logger.log("=".repeat(50));
    Logger.log(`üìà RESUMO DA IMPORTA√á√ÉO HIST√ìRICA:`);
    Logger.log(`  ‚úÖ Total enviado para Firebase: ${totalEnviado}`);
    Logger.log(`  ‚ö†Ô∏è  Total ignorados (vazios/inv√°lidos): ${totalIgnorados}`);
    Logger.log(`  ‚ùå Total com erro: ${totalErros}`);
    Logger.log(`  üìä Total processado: ${totalEnviado + totalIgnorados + totalErros} de ${rows.length}`);
    Logger.log(`  üì¶ Total de lotes processados: ${totalLotes}`);
    Logger.log("=".repeat(50));
    Logger.log(`‚úÖ Importa√ß√£o conclu√≠da! Verifique o Firebase para confirmar os dados.`);
    
  } catch (e) {
    Logger.log(`‚ùå Erro na importa√ß√£o em lotes: ${e.message}`);
    Logger.log(`   Stack: ${e.stack}`);
  }
}

/**
 * Mapeia uma linha da planilha para objeto candidato
 */
function rowToCandidateObject(row, headers) {
  const get = (headerName) => {
    const index = headers.indexOf(headerName);
    return (index > -1 && row[index]) ? String(row[index]).trim() : "";
  };

  // Metadados - IMPORTANTE: Converter para timestamp do Firestore
  const agora = new Date();
  const timestampOriginal = get('Carimbo de data/hora');
  
  // Converte data/hora original para timestamp
  let originalDate = agora;
  if (timestampOriginal) {
    try {
      originalDate = new Date(timestampOriginal);
      if (isNaN(originalDate.getTime())) {
        originalDate = agora;
      }
    } catch (e) {
      originalDate = agora;
    }
  }
  
  const candidato = {
    // Metadados
    external_id: get('COD') || "",
    createdAt: {
      timestampValue: agora.toISOString()
    },
    original_timestamp: {
      timestampValue: originalDate.toISOString()
    },
    origin: "batch_script",
    createdBy: "Batch Import Script",
    
    // Identifica√ß√£o e Contato
    fullName: get('Nome completo:'),
    email: get('E-mail principal:') || get('Endere√ßo de e-mail'),
    email_secondary: get('Endere√ßo de e-mail') || "",
    phone: get('N¬∫ telefone celular / Whatsapp:'),
    
    // Dados Pessoais
    birthDate: formatarData(get('Data de Nascimento:')),
    age: parseInt(get('Idade')) || 0,
    photoUrl: get('Nos envie uma foto atual que voc√™ goste:'),
    maritalStatus: get('Estado civil:') || "",
    childrenCount: parseInt(get('Se tem filhos, quantos?')) || 0,
    hasLicense: get('Voc√™ possui CNH tipo B?') || "",
    
    // Localiza√ß√£o
    city: normalizarCidade(get('Cidade onde reside:')),
    
    // Profissional e Acad√™mico
    education: get('Forma√ß√£o:'),
    schoolingLevel: get('N√≠vel de escolaridade:'),
    institution: get('Institui√ß√£o de ensino:'),
    graduationDate: formatarData(get('Data de formatura:')),
    isStudying: get('Em caso de curso superior, est√° cursando neste momento?') || "",
    experience: get('Experi√™ncias anteriores:'),
    courses: get('Cursos e certifica√ß√µes profissionais.') || "",
    certifications: get('Certifica√ß√µes profissionais:') || "",
    interestAreas: normalizeInterests(get('√Åreas de interesse profissional')),
    
    // Links
    cvUrl: get('Anexar curr√≠culo:'),
    portfolioUrl: get('Portf√≥lio de trabalho:'),
    
    // Processo e Fit Cultural
    source: normalizarSource(get('Onde voc√™ nos encontrou?') || "Legado"),
    referral: get('Voc√™ foi indicado por algum colaborador da Young? Se sim, quem?') || "",
    salaryExpectation: get('Qual seria sua expectativa salarial?') || "",
    canRelocate: get('Teria disponibilidade para mudan√ßa de cidade?') || "",
    references: get('Refer√™ncias profissionais:') || "",
    typeOfApp: get('Voc√™ est√° se candidatando a uma vaga espec√≠fica...?') || "",
    freeField: get('Campo Livre, SEJA VOC√ä!') || "",
    
    // Status do Pipeline
    status: "Inscrito",
    
    // Tags
    tags: ["Importado CSV"],
    
    // Metadados de origem e cria√ß√£o
    origin: "batch_script", // Origem: script de importa√ß√£o em lote (appscript)
    createdBy: "system", // Sistema (script)
    responsibleUser: "", // Vazio para importa√ß√£o em lote
    imported: true
  };

  return candidato;
}

/**
 * Envia lote de opera√ß√µes para o Firebase (para importa√ß√£o em massa)
 */
function enviarBatchFirestore(writesArray) {
  const token = getServiceAccountToken();
  const payload = { writes: writesArray };
  const options = {
    method: "post",
    contentType: "application/json",
    headers: { Authorization: "Bearer " + token },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };
  
  const response = UrlFetchApp.fetch(FIRESTORE_BATCH_URL, options);
  const statusCode = response.getResponseCode();
  
  if (statusCode !== 200) {
    const errorText = response.getContentText();
    Logger.log(`  ‚ö†Ô∏è  Resposta do Firebase: Status ${statusCode}`);
    Logger.log(`  ‚ö†Ô∏è  Erro: ${errorText}`);
    throw new Error(`Erro Firebase (${statusCode}): ${errorText}`);
  }
}

// ============================================================================
// FUN√á√ÉO DE TESTE
// ============================================================================
/**
 * Fun√ß√£o para testar o envio manualmente
 * Simula o envio de um formul√°rio
 */
function testeEnvio() {
  try {
    // Simula dados de um formul√°rio
    const testResponses = {
      'Carimbo de data/hora': [new Date().toISOString()],
      'Nome completo:': ['Teste Candidato'],
      'E-mail principal:': ['teste@exemplo.com'],
      'N¬∫ telefone celular / Whatsapp:': ['(51) 99999-9999'],
      'Cidade onde reside:': ['porto alegre'],
      'Experi√™ncias anteriores:': ['Teste de experi√™ncia profissional']
    };
    
    const candidato = mapearFormularioParaCandidato(testResponses);
    Logger.log("üìù Dados mapeados:");
    Logger.log(JSON.stringify(candidato, null, 2));
    
    // Testa verifica√ß√£o de duplicata
    if (candidato.email) {
      Logger.log(`üîç Verificando se j√° existe: ${candidato.email}`);
      const existe = verificarCandidatoExistente(candidato.email);
      if (existe) {
        Logger.log(`‚ö†Ô∏è  J√° existe! ID: ${existe.docId}`);
        return;
      }
    }
    
    const resultado = enviarCandidatoParaFirebase(candidato);
    
    if (resultado.sucesso) {
      Logger.log("‚úÖ Teste enviado com sucesso!");
      Logger.log(`   ID do documento: ${resultado.docId}`);
    } else {
      Logger.log("‚ùå Erro no teste:");
      Logger.log(`   ${resultado.erro}`);
    }
    
  } catch (e) {
    Logger.log("‚ùå Erro no teste: " + e.message);
    Logger.log("Stack: " + e.stack);
  }
}
